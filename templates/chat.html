{% extends "_layout.html" %}

{% block title %}Sahaay-AI Daily Check-in{% endblock %}

{% block content %}
<div id="mainContainer" class="flex flex-col min-h-screen">
  <header class="flex justify-between items-center mb-6 bg-theme-panel p-4 rounded-2xl shadow animated-item">
    <h1 id="pageTitle" class="text-xl font-semibold text-theme-text-main">Daily Check-in</h1>
    <div class="flex items-center gap-3">
      <a href="/dashboard" id="dashboardLink" class="flex items-center gap-2 px-4 py-2 btn-primary rounded-lg shadow-md hover:opacity-90 transition" aria-label="Open Dashboard">
        <i data-lucide="home"></i> Dashboard
      </a>
      <div class="relative inline-block text-left">
        <button id="userDropdownBtn" class="flex items-center justify-center w-10 h-10 bg-theme-panel rounded-full focus:outline-none focus:ring-2 focus:ring-theme-accent transition" aria-haspopup="true" aria-expanded="true" aria-label="User menu">
          <i data-lucide="user"></i>
        </button>
        <div id="userDropdownMenu" class="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-theme-panel ring-1 ring-black ring-opacity-5 transition hidden z-[1000]" role="menu" aria-orientation="vertical" aria-labelledby="userDropdownBtn">
          <div class="py-1" role="none">
            <div id="usernameDisplay" class="px-4 py-2 text-sm" role="menuitem">
              <span id="displayName">Loading...</span>
            </div>
            <hr class="border-theme-primary mx-2">
            <div id="anonymousToggle" class="block px-4 py-2 text-sm hover:bg-theme-accent transition" role="menuitem">
              <div class="flex items-center justify-between">
                <span>Anonymous Mode</span>
                <label class="flex items-center cursor-pointer">
                  <div class="relative">
                    <input type="checkbox" id="anonymousCheckbox" class="sr-only" aria-label="Enable anonymous mode">
                    <div class="block bg-theme-hover w-10 h-6 rounded-full"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition-all duration-300"></div>
                  </div>
                </label>
              </div>
            </div>
            <a href="#" id="eraseBtn" class="flex items-center gap-2 px-4 py-2 text-sm text-theme-pulse hover:bg-theme-pulse/20 hover:text-white rounded-md transition" aria-label="Delete all data">
              <i data-lucide="trash-2" class="w-4 h-4"></i> Delete Data
            </a>
            <a href="/logout" id="logoutBtn" class="flex items-center gap-2 px-4 py-2 text-sm hover:bg-theme-accent rounded-md transition" role="menuitem" aria-label="Logout">
              <i data-lucide="log-out" class="w-4 h-4"></i> Logout
            </a>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div id="crisisBanner" class="bg-red-500 text-white p-4 rounded-xl shadow-md text-sm text-center mb-4 hidden">
    <p>If you or someone you know is in crisis, please seek immediate help.</p>
    <button id="helpResourcesBtn" class="underline font-bold mt-1">View Helplines & Resources</button>
  </div>

  <div id="consent-card" class="bg-theme-panel rounded-2xl shadow p-4 mb-4 animated-item">
    <h2 class="text-lg font-semibold mb-2 text-theme-text-main">Consent Status <span title="Data is anonymized, kept for 30 days">‚ùì</span></h2>
    <p id="consent-status" class="text-theme-text-subtle">Loading...</p>
  </div>

  <div class="flex flex-col flex-1 bg-theme-panel rounded-2xl shadow overflow-hidden animated-item">
    <div id="chatBox" class="flex-1 flex flex-col gap-3 p-4 overflow-y-auto" role="log" aria-live="polite"></div>
    <div class="p-2 border-t border-theme-primary bg-theme-panel">
      <div class="emoji-row flex gap-2 items-center">
        <button class="px-2 py-1" aria-label="Add happy emoji">üòÄ</button>
        <button class="px-2 py-1" aria-label="Add sad emoji">üò¢</button>
        <button class="px-2 py-1" aria-label="Add anxious emoji">üò∞</button>
        <button class="px-2 py-1" aria-label="Add calm emoji">üòå</button>
        <button class="px-2 py-1" aria-label="Add heart emoji">‚ù§Ô∏è</button>
      </div>
    </div>
    <div class="flex gap-2 items-center p-3 border-t border-theme-primary bg-theme-panel">
      <input id="message" type="text" placeholder="Type your message..."
        class="flex-1 p-3 rounded-xl border-theme-primary focus:outline-none focus:ring-2 focus:ring-theme-accent bg-theme-panel text-theme-text-main" aria-label="Type your message">
      <button id="sendBtn" class="flex items-center gap-2 btn-primary px-6 py-3 rounded-xl hover:opacity-90 transition" aria-label="Send message">
        <i data-lucide="send"></i> <span id="sendText">Send</span>
        <span id="sendSpinner" class="hidden" aria-hidden="true"><span class="send-spinner" /></span>
      </button>
    </div>
  </div>

  <p id="chatError" class="text-theme-pulse mt-2 hidden" role="status"></p>

  <footer class="text-center text-xs text-theme-text-subtle mt-4">
    <p><a href="/privacy" class="underline">Privacy & Data Policy</a></p>
    <button id="resetConsentBtn"
            class="mt-2 px-3 py-1 bg-theme-pulse text-white text-xs rounded hover:bg-theme-pulse/80">
      Reset Consent
    </button>
  </footer>
</div>

<!-- Consent Modal -->
<div id="consentModal" role="dialog" aria-labelledby="consentTitle" aria-describedby="consentDesc" tabindex="0"
     class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-[9999] hidden">
  <div class="bg-theme-panel rounded-2xl p-6 w-[90%] max-w-md flex flex-col gap-4">
    <h2 id="consentTitle" class="text-xl font-semibold text-theme-text-main">Privacy & Consent</h2>
    <p id="consentDesc" class="text-sm text-theme-text-subtle">
      We store only anonymized mood check-ins to improve wellbeing support. You can continue
      <b>with consent</b> (data helps insights) or in <b>anonymous mode</b> (no storage). You can delete your data anytime.
    </p>
    <div class="flex flex-col gap-2">
      <button id="consentAgree" class="btn-primary px-6 py-3 rounded-xl hover:opacity-90 transition" tabindex="0">
        I Agree (Save Anonymized Check-ins)
      </button>
      <button id="consentAnon" class="bg-theme-panel text-theme-text-main px-6 py-3 rounded-xl hover:opacity-90 transition" tabindex="0">
        Use Anonymous Mode (Don‚Äôt Save)
      </button>
      <button id="consentExit" class="text-sm text-theme-text-subtle underline" tabindex="0">
        Exit
      </button>
    </div>
    <p class="text-xs text-theme-text-subtle">
      Retention: 30 days ‚Ä¢ Right to Erase: ‚ÄúDelete my data‚Äù in header ‚Ä¢ Crisis: Helplines available
    </p>
  </div>
</div>
{% endblock %}

{% block page_scripts %}
<style>
  #mainContainer { height: 100vh; overflow: hidden; }
  #chatBox {
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: #14b8a6 transparent;
  }
  #chatBox::-webkit-scrollbar { width: 10px; }
  #chatBox::-webkit-scrollbar-track { background: transparent; }
  #chatBox::-webkit-scrollbar-thumb {
    background-color: rgba(20, 184, 166, 0.5);
    border-radius: 8px;
    border: 2px solid transparent;
    background-clip: content-box;
  }
  #chatBox:hover::-webkit-scrollbar-thumb { background-color: rgba(20, 184, 166, 0.8); }

  #sidebar { display: none !important; }
  #mainContent { margin-left: 0 !important; }
</style>

<script src="https://unpkg.com/lucide@latest"></script>
<script>
  // ===== DOM REFS =====
  const chatBox = document.getElementById('chatBox');
  const input = document.getElementById('message');
  const sendBtn = document.getElementById('sendBtn');
  const sendSpinner = document.getElementById('sendSpinner');
  const sendText = document.getElementById('sendText');
  const chatError = document.getElementById('chatError');
  const crisisBanner = document.getElementById('crisisBanner');
  const consentModal = document.getElementById('consentModal');
  const mainContainer = document.getElementById('mainContainer');
  const consentAgreeBtn = document.getElementById('consentAgree');
  const consentAnonBtn = document.getElementById('consentAnon');
  const consentExitBtn = document.getElementById('consentExit');
  const consentStatusEl = document.getElementById('consent-status');
  const dashboardLink = document.getElementById('dashboardLink');
  const resetConsentBtn = document.getElementById('resetConsentBtn');
  const emojiButtons = document.querySelectorAll('.emoji-row button');
  const helpResourcesBtn = document.getElementById('helpResourcesBtn');

  // Dropdown
  const userDropdownBtn = document.getElementById('userDropdownBtn');
  const userDropdownMenu = document.getElementById('userDropdownMenu');
  const anonymousCheckbox = document.getElementById('anonymousCheckbox');
  const displayNameSpan = document.getElementById('displayName');
  const eraseBtn = document.getElementById('eraseBtn');

  let currentLang = 'en';
  let STORAGE_KEY = null;

  function getLocalISODate() {
  try {
    return new Date().toLocaleDateString('en-CA', { timeZone: 'Asia/Kolkata' }); // YYYY-MM-DD
  } catch (e) {
    return new Date().toISOString().slice(0,10); // fallback
  }
}

  // Build storage key per-mode + per-day + per-user
  async function getStorageKey() {
    if (STORAGE_KEY) return STORAGE_KEY;
    const today = getLocalISODate();
    try {
      const res = await fetch('/api/consent_status');
      const data = await res.json();
      const has_consent = !!data.has_consent;
      if (has_consent) {
        const ures = await fetch('/api/get_user_info');
        const u = await ures.json();
        const uid = u.user_id || 'guest';
        STORAGE_KEY = `chat_history_consented_${uid}_${today}`;
      } else {
        // Anonymous per-day key; clicking anonymous should clear it (fresh session)
        STORAGE_KEY = `chat_history_anonymous_${today}`;
      }
      return STORAGE_KEY;
    } catch (e) {
      // fallback
      STORAGE_KEY = `chat_history_anonymous_${today}`;
      return STORAGE_KEY;
    }
  }

  async function persistLocalMessage(obj) {
    const key = await getStorageKey();
    const history = JSON.parse(localStorage.getItem(key) || '[]');
    history.push(obj);
    if (history.length > 200) history.splice(0, history.length - 200);
    localStorage.setItem(key, JSON.stringify(history));
  }

  // Append message UI & optionally persist locally (server persistence is handled server-side when consented)
  function appendMessage(text, sender, persist=true, ts=null) {
    const row = document.createElement('div');
    row.className = `flex gap-3 items-start ${sender==='user' ? 'justify-end' : 'justify-start'} msg-fade`;
    row.style.alignItems = 'flex-end';

    const avatar = document.createElement('div');
    avatar.className = 'avatar';
    avatar.style.userSelect = 'none';
    avatar.style.fontSize = '16px';
    avatar.textContent = sender === 'user' ? 'üë§' : 'ü§ñ';

    const bubble = document.createElement('div');
    bubble.className = `${sender==='user' ? 'bg-teal-600 text-white rounded-br-none self-end ml-auto' : 'bg-gray-200 text-gray-800 dark:bg-gray-700 dark:text-gray-100 rounded-bl-none self-start'} p-3 rounded-2xl max-w-[70%] shadow-md`;

    const textEl = document.createElement('div');
    textEl.textContent = text;
    bubble.appendChild(textEl);

    const timestampEl = document.createElement('div');
    timestampEl.className = `${sender==='user' ? 'text-white/80' : 'text-gray-500 dark:text-gray-300'} text-[10px] mt-1 text-right`;
    try {
      const date = ts ? new Date(ts) : new Date();
      timestampEl.textContent = `${String(date.getHours()).padStart(2,'0')}:${String(date.getMinutes()).padStart(2,'0')}`;
      bubble.appendChild(timestampEl);
    } catch(e) {}

    if (sender === 'user') {
      row.appendChild(bubble);
      row.appendChild(avatar);
    } else {
      row.appendChild(avatar);
      row.appendChild(bubble);
    }

    chatBox.appendChild(row);
    chatBox.scrollTop = chatBox.scrollHeight;

    if (persist) persistLocalMessage({ sender, text, ts: ts || Date.now() });
  }

  // ====== Server conversation fetch (only when consented) =====
  async function fetchServerConversationIfConsented() {
    try {
      const cs = await fetch('/api/consent_status');
      const { has_consent } = await cs.json();
      const today = getLocalISODate();
      const key = await getStorageKey();

      if (has_consent) {
        // fetch conversation messages for today from server
        const res = await fetch(`/api/fetch_conversation?date=${today}`);
        const data = await res.json();
        if (data.messages && data.messages.length) {
          // show server messages (and overwrite local cache to avoid duplicates)
          chatBox.innerHTML = '';
          data.messages.forEach(m => appendMessage(m.text, m.sender, false, m.ts));
          // update local cache to match server (fast subsequent loads)
          const localCache = data.messages.map(m => ({ sender: m.sender, text: m.text, ts: m.ts }));
          localStorage.setItem(key, JSON.stringify(localCache));
          // mark greeted so we don't re-greet
          localStorage.setItem(`greeted_${key}`, today);
          return true;
        }
      }
      return false;
    } catch (e) {
      console.error('fetchServerConversationIfConsented err', e);
      return false;
    }
  }

  // Restore chat history: prefer server messages if consented; fallback to localStorage
  async function restoreChatHistory() {
    const key = await getStorageKey();
    const usedServer = await fetchServerConversationIfConsented();
    if (usedServer) return;
    const history = JSON.parse(localStorage.getItem(key) || '[]');
    history.forEach(m => appendMessage(m.text, m.sender, false, m.ts));
  }

  // ====== Greeting once per-day per-mode ======
  async function maybeGreetOncePerDay() {
    const key = await getStorageKey();
    const today = getLocalISODate();
    const greetedKey = `greeted_${key}`;
    const lastGreet = localStorage.getItem(greetedKey);
    if (lastGreet === today) return;
    const res = await fetch(`/daily_checkin_prompt?lang=${currentLang}`);
    const data = await res.json();
    if (data.prompt) {
      appendMessage(data.prompt, 'bot');
      localStorage.setItem(greetedKey, today);
    }
  }

  // ====== Consent state & toggles ======
  async function updateConsentStatus() {
    try {
      const res = await fetch('/api/consent_status');
      const data = await res.json();
      if (data.has_consent) {
        consentModal.classList.add('hidden');
        mainContainer.classList.remove('hidden');
        consentStatusEl.textContent = "Consent Given ‚úÖ";
        anonymousCheckbox.checked = false;
      } else {
        consentModal.classList.remove('hidden');
        mainContainer.classList.add('hidden');
        consentStatusEl.textContent = "Anonymous Mode (No data is saved)";
        anonymousCheckbox.checked = true;
      }
    } catch (e) {
      console.error('consent status error', e);
      consentModal.classList.remove('hidden');
      consentStatusEl.textContent = "Unknown - offline?";
    }
  }

  // Accept consent via modal
  consentAgreeBtn.addEventListener('click', async () => {
    try {
      await fetch('/api/submit_consent', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ consent: true })
      });
      // after giving consent, reload so frontend keys and server state match
      location.reload();
    } catch (e) { console.error(e); }
  });

  // Anonymous via modal - clear local anon key to ensure fresh chat
  consentAnonBtn.addEventListener('click', async () => {
    try {
      await fetch('/api/submit_consent', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ consent: false })
      });
      // clear local per-day anon key so next chat is fresh
      const anonKey = `chat_history_anonymous_${getLocalISODate()}`;
      localStorage.removeItem(anonKey);
      location.reload();
    } catch (e) { console.error(e); }
  });

  consentExitBtn.addEventListener('click', () => { window.location.href = 'https://www.google.com'; });

  // Reset consent (backend + local)
  resetConsentBtn.addEventListener('click', async () => {
    try {
      await fetch('/api/reset_consent', { method: 'POST' });
      // clear local storage for both modes of today
      localStorage.removeItem(`chat_history_anonymous_${getLocalISODate()}`);
      // try to clear consented user key if known
      const u = await (await fetch('/api/get_user_info')).json();
      if (u && u.user_id) localStorage.removeItem(`chat_history_consented_${u.user_id}_${getLocalISODate()}`);
      localStorage.clear(); // full clear is simplest to avoid leftover keys
      location.reload();
    } catch (e) { console.error(e); }
  });

  // Toggle from user dropdown
  userDropdownBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (userDropdownMenu.parentNode !== document.body) document.body.appendChild(userDropdownMenu);
    userDropdownMenu.classList.toggle('hidden');
    if (!userDropdownMenu.classList.contains('hidden')) {
      const rect = userDropdownBtn.getBoundingClientRect();
      userDropdownMenu.style.position = 'fixed';
      userDropdownMenu.style.top = `${rect.bottom + 8}px`;
      userDropdownMenu.style.left = `${Math.max(8, Math.min(window.innerWidth - 8 - userDropdownMenu.offsetWidth, rect.right - userDropdownMenu.offsetWidth))}px`;
      userDropdownMenu.style.zIndex = '20000';
    }
  });
  window.addEventListener('click', e => {
    if (!userDropdownBtn.contains(e.target) && !userDropdownMenu.contains(e.target)) userDropdownMenu.classList.add('hidden');
  });

  // anonymous checkbox in dropdown: when toggled ON => set anonymous (server)
  anonymousCheckbox.addEventListener('change', async () => {
    if (anonymousCheckbox.checked) {
      // set consent false on server
      await fetch('/api/submit_consent', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ consent: false }) });
      // clear local anon key for fresh chat
      localStorage.removeItem(`chat_history_anonymous_${getLocalISODate()}`);
      showToast('Anonymous mode enabled ‚Äî your messages will not be saved.');
      // reload so UI reflects anonymous
      location.reload();
    } else {
      // turn off anonymous: ask server to set consent = true (user must confirm)
      // We'll redirect user to consent modal (they must explicitly agree)
      consentModal.classList.remove('hidden');
    }
  });

  // show tiny toast
  function showToast(msg, type='success') {
    // very lightweight
    const el = document.createElement('div');
    el.textContent = msg;
    el.style.position = 'fixed';
    el.style.bottom = '20px';
    el.style.left = '50%';
    el.style.transform = 'translateX(-50%)';
    el.style.padding = '8px 12px';
    el.style.borderRadius = '8px';
    el.style.color = '#fff';
    el.style.background = type === 'success' ? '#10B981' : '#EF4444';
    el.style.zIndex = 99999;
    document.body.appendChild(el);
    setTimeout(()=>el.remove(), 2500);
  }

  // Erase stored user check-ins + conversations (calls backend erase)
  eraseBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    if (!confirm('This will delete all of your stored check-ins and conversations. Continue?')) return;
    try {
      const res = await fetch('/erase', { method: 'POST' });
      const data = await res.json();
      if (data.ok) {
        // clear local caches for today
        localStorage.removeItem(`chat_history_anonymous_${getLocalISODate()}`);
        const u = await (await fetch('/api/get_user_info')).json();
        if (u && u.user_id) localStorage.removeItem(`chat_history_consented_${u.user_id}_${getLocalISODate()}`);
        chatBox.innerHTML = '';
        showToast(`Deleted ${data.deleted || 0} entries.`, 'success');
      } else {
        showToast(`Erase failed: ${data.error || 'unknown'}`, 'error');
      }
    } catch (err) {
      showToast('Erase failed. Try again later.', 'error');
      console.error(err);
    }
  });

  // Emoji quick buttons
  emojiButtons.forEach(btn => btn.addEventListener('click', () => {
    input.value = (input.value ? input.value + ' ' : '') + btn.textContent;
    input.focus();
  }));
  // ======== Chat sending & display =========
  let slowSpinnerTimer = null;
  function showSlowSpinner() { sendSpinner.classList.remove('hidden'); sendText.style.display = 'none'; }
  function hideSlowSpinner() { sendSpinner.classList.add('hidden'); sendText.style.display = ''; }

  function toggleCrisisBanner(show) {
  if (!crisisBanner) return;
  if (show) crisisBanner.classList.add('show');
  else crisisBanner.classList.remove('show');
}

// Update sendMessage
async function sendMessage(msg) {
  if (!msg || !msg.trim()) return;
  appendMessage(msg, 'user', true);
  input.value = '';
  slowSpinnerTimer = setTimeout(showSlowSpinner, 1500);

  try {
    const res = await fetch('/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: msg, lang: currentLang, local_date: getLocalISODate() })
    });
    clearTimeout(slowSpinnerTimer);
    hideSlowSpinner();
    const result = await res.json();

    if (result.ok && result.data) {
      const botText = result.data.response || "I'm here to listen. Can you tell me more?";
      appendMessage(botText, 'bot', true);
      toggleCrisisBanner(!!result.data.crisis_detected);
    } else {
      const errMsg = result.message || 'Failed to send message.';
      chatError.textContent = errMsg;
      chatError.classList.remove('hidden');
      appendMessage(errMsg, 'bot', true);
      toggleCrisisBanner(false);
    }
  } catch (err) {
    clearTimeout(slowSpinnerTimer);
    hideSlowSpinner();
    console.error(err);
    appendMessage("Network error. Please try again.", 'bot', true);
    toggleCrisisBanner(false);
  }
}

// Helpline button
helpResourcesBtn?.addEventListener('click', () => {
  window.open('https://www.mentalhealth.gov/get-help', '_blank');
});

  sendBtn.addEventListener('click', () => sendMessage(input.value));
  input.addEventListener('keypress', e => { if (e.key === 'Enter') sendMessage(input.value); });

  // ======= Fetch user display name and initial flow =======
  async function fetchUserDisplayName() {
    try {
      const res = await fetch('/api/get_user_info');
      const data = await res.json();
      displayNameSpan.textContent = data.username || 'Guest';
      anonymousCheckbox.checked = !!data.is_anonymous;
      dashboardLink.style.display = data.is_anonymous ? 'none' : '';
      // erase button visibility only if consent saved
      eraseBtn.style.display = data.is_anonymous ? 'none' : '';
    } catch (e) {
      displayNameSpan.textContent = 'Guest';
      anonymousCheckbox.checked = true;
      dashboardLink.style.display = 'none';
      eraseBtn.style.display = 'none';
    }
  }

  function cleanupLocalChats(retentionDays = 7) {
    const nowStr = getLocalISODate();
    for (let i = localStorage.length - 1; i >= 0; i--) {
      const key = localStorage.key(i);
      if (!key || !key.startsWith('chat_history_')) continue;
      const parts = key.split('_');
      const datePart = parts[parts.length - 1];
      if (!/^\d{4}-\d{2}-\d{2}$/.test(datePart)) continue;
      const diffDays = Math.round((new Date(nowStr) - new Date(datePart)) / (1000*60*60*24));
      if (diffDays > retentionDays) localStorage.removeItem(key);
    }
  }

  document.addEventListener('DOMContentLoaded', async () => {
    cleanupLocalChats(7);
    await updateConsentStatus();
    // If modal is visible user must choose before we show chat
    if (!consentModal.classList.contains('hidden')) return;
    await fetchUserDisplayName();
    await restoreChatHistory();
    await maybeGreetOncePerDay();
    lucide.createIcons();
  });
</script>
{% endblock %}
